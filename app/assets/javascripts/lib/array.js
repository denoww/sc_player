// Generated by CoffeeScript 2.4.1
(function() {
  // -------------------------
  // array.js
  var indexOf = [].indexOf;

  Array.prototype.max = function() {
    return Math.max.apply(null, this);
  };

  Array.prototype.min = function() {
    return Math.min.apply(null, this);
  };

  Array.prototype.first = function() {
    return this[0];
  };

  Array.prototype.last = function() {
    return this.slice(-1)[0];
  };

  Array.prototype.clone = function() {
    return this.slice(0);
  };

  Array.prototype.intersection = function(array) {
    var resp;
    resp = this.filter(function(n) {
      return array.indexOf(n) !== -1;
    });
    return resp.unique();
  };

  Array.prototype.toggle = function(value) {
    var array, index;
    array = this;
    index = array.indexOf(value);
    if (index === -1) {
      array.push(value);
    } else {
      array.splice(index, 1);
    }
  };

  Array.prototype.inArray = function(e) {
    return indexOf.call(this, e) >= 0;
  };

  Array.prototype.contains = function(e) {
    return indexOf.call(this, e) >= 0;
  };

  Array.prototype.include = function(e) {
    return this.inArray(e);
  };

  Array.prototype.one = function() {
    return this.length === 1;
  };

  Array.prototype.any = function() {
    return this.length > 0;
  };

  Array.prototype.many = function() {
    return this.length > 1;
  };

  Array.prototype.empty = function() {
    return !this.any();
  };

  Array.prototype.index = function(value, field) {
    return this.transform(field).indexOf(value);
  };

  Array.prototype.transform = function(field, clone = false) {
    if (field != null) {
      return this.map(function(e) {
        return e[field];
      });
    } else if (clone) {
      return this.clone();
    } else {
      return this;
    }
  };

  Array.prototype.sortByField = function(field, type = 'asc') {
    return this.slice(0).sort(function(a, b) {
      switch (type) {
        case 'asc':
          if (a[field] > b[field]) {
            return 1;
          } else if (a[field] < b[field]) {
            return -1;
          } else {
            return 0;
          }
          break;
        case 'desc':
          if (a[field] > b[field]) {
            return -1;
          } else if (a[field] < b[field]) {
            return 1;
          } else {
            return 0;
          }
      }
    });
  };

  Array.prototype.indexOfById = function(id) {
    var el, idx, j, len, ref;
    ref = this;
    for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
      el = ref[idx];
      if (el.id === id) {
        return idx;
      }
    }
    return -1;
  };

  Array.prototype.getById = function(id) {
    if (id instanceof Array) {
      return id.map((_id) => {
        return this.getById(_id);
      });
    } else {
      return this[this.indexOfById(id)];
    }
  };

  Array.prototype.move = function(from, to) {
    return this.splice(to, 0, this.splice(from, 1)[0]);
  };

  Array.prototype.remove = function(el) {
    var idx;
    idx = this.indexOf(el);
    if (idx > -1) {
      return this.splice(idx, 1);
    }
  };

  Array.prototype.removeAll = function(el) {
    var results;
    results = [];
    while (indexOf.call(this, el) >= 0) {
      results.push(this.remove(el));
    }
    return results;
  };

  Array.prototype.removeById = function(id) {
    return this.removeByField('id', id);
  };

  Array.prototype.getByField = function(field, value) {
    var idx;
    idx = this.getIndexByField(field, value);
    return this[idx];
  };

  Array.prototype.getIndexByField = function(field, value) {
    var el, i, idx, j, len, ref;
    if (field === void 0) {
      field = 'id';
    }
    idx = null;
    ref = this;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      el = ref[i];
      if (el[field] === value) {
        idx = i;
      }
    }
    return idx;
  };

  Array.prototype.removeByField = function(field, value) {
    var el, i, idx, j, len, ref, results;
    if (field === void 0) {
      field = 'id';
    }
    idx = [];
    ref = this;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      el = ref[i];
      if (el[field] === value) {
        idx.push(i);
      }
    }
    results = [];
    while (idx.length > 0) {
      results.push((this.splice(idx.pop(), 1))[0]);
    }
    return results;
  };

  Array.prototype.extractFrom = function(deepObject) {
    var _attr, _carry, j, len, ref;
    _carry = deepObject;
    ref = this;
    for (j = 0, len = ref.length; j < len; j++) {
      _attr = ref[j];
      _carry = _carry != null ? _carry[_attr] : void 0;
    }
    return _carry;
  };

  Array.prototype.addOrExtend = function(obj) {
    var idx;
    idx = obj.id != null ? this.indexOfById(obj.id) : this.indexOf(obj);
    if (idx === -1) {
      return this.push(obj);
    } else {
      return Object.assign(this[idx], obj);
    }
  };

  Array.prototype.somar = function(field) {
    var _arr;
    _arr = field ? this.map(function(e) {
      return e[field];
    }) : this;
    return _arr.reduce(function(mem, el) {
      return +mem + +el;
    });
  };

  Array.prototype.chunk = function(size = 2) {
    var e, i, j, len, ref, ref1, results;
    ref1 = this;
    ref = size;
    results = [];
    for ((ref > 0 ? (i = j = 0, len = ref1.length) : i = j = ref1.length - 1); ref > 0 ? j < len : j >= 0; i = j += ref) {
      e = ref1[i];
      results.push(this.slice(i, i + size));
    }
    return results;
  };

  Array.prototype.diffById = function(arr) {
    var result;
    result = this.map(function(item) {
      if (arr.indexOfById(item.id) < 0) {
        return item;
      }
    });
    result.removeAll(void 0);
    return result;
  };

  Array.prototype.compact = function() {
    return this.filter(function(e) {
      return !!e || e === 0;
    });
  };

  Array.prototype.unique = function(field) {
    var added;
    added = [];
    return this.filter(function(item) {
      var v;
      v = field != null ? item[field] : item;
      if (indexOf.call(added, v) < 0) {
        return added.push(v);
      }
    });
  };

  Array.prototype.clear = function() {
    this.length = 0;
    return this;
  };

  Array.prototype.sum = function() {
    if (!this.length) {
      return 0;
    }
    return this.reduce(function(mem, el) {
      return +mem + +el;
    });
  };

  Array.prototype.find = function(fn) {
    return this.select(fn)[0];
  };

  Array.prototype.select = function(fn) {
    var el, j, len, ref, results;
    ref = this;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      el = ref[j];
      if (!!fn(el)) {
        results.push(el);
      }
    }
    return results;
  };

  Array.prototype.reject = function(fn) {
    var el, j, len, ref, results;
    ref = this;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      el = ref[j];
      if (!fn(el)) {
        results.push(el);
      }
    }
    return results;
  };

  Array.prototype.flatten = function() {
    var b, self;
    self = this.clone();
    while (self.length !== (b != null ? b.length : void 0)) {
      b = self;
      self = [].concat(...self);
    }
    return self;
  };

  // Porque a de cima tá mais batutinha.
  // Array::flatten = e = ->
  //   t = []
  //   n = 0
  //   r = @length

  //   while n < r
  //     i = Object::toString.call(this[n]).split(" ").pop().split("]").shift().toLowerCase()
  //     t = t.concat((if /^(array|collection|arguments|object)$/.test(i) then e.call(this[n]) else this[n]))  if i
  //     n++
  //   t
  Array.prototype.presence = function() {
    if (this.empty()) {
      return null;
    } else {
      return this;
    }
  };

  Array.prototype.toSentence = function() {
    if (this.empty()) {
      return '';
    }
    if (this.length === 1) {
      return this.first();
    }
    return [this.slice(0, -1).join(', '), this.last()].join(' e ');
  };

  // Aguardando confirmação de não bugs
  // Array::toSentence = ->
  //   e = this
  //   if @length is 0
  //     ""
  //   else if @length is 1
  //     this[0]
  //   else
  //     t = @length - 1
  //     n = this[t]
  //     e.splice t, 1
  //     primeiros = e.join(", ")
  //     [primeiros, n].join " e "
  Array.prototype.occurrencesOf = function(e) {
    var el;
    return ((function() {
      var j, len, ref, results;
      ref = this;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        el = ref[j];
        if (el === e) {
          results.push(el);
        }
      }
      return results;
    }).call(this)).length;
  };

  // Aguardando confirmação de não bugs
  // Array::occurrencesOf = (e) ->
  //   t = {}
  //   n = 0

  //   while n < @length
  //     r = this[n]
  //     t[r] = (if t[r] then t[r] + 1 else 1)
  //     n++
  //   result = t[e]
  //   if result is `undefined`
  //     0
  //   else
  //     result

  // Como usar o foreach
  // [12, 5, 8, 130, 44].forEach(function(element, index, array){
  // });
  // ou
  // [12, 5, 8, 130, 44].forEach(function(element){
  // ou
  // [12, 5, 8, 130, 44].forEach (element) ->
  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(fn) {
      var el, idx, j, len, ref, results;
      if (typeof e !== "function") {
        throw new TypeError;
      }
      ref = this;
      results = [];
      for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
        el = ref[idx];
        results.push(fn(el, idx, this));
      }
      return results;
    };
  }

  // unless @Array::forEach
//   @Array::forEach = (e) ->
//     # Como usar o foreach
//     # [12, 5, 8, 130, 44].forEach(function(element, index, array){
//     # });
//     # ou
//     # [12, 5, 8, 130, 44].forEach(function(element){
//     # ou
//     # [12, 5, 8, 130, 44].forEach (element) ->

//     t = @length
//     throw new TypeError unless typeof e is "function"
//     n = arguments[1]
//     r = 0

//     while r < t
//       e.call n, this[r], r, this if r of this
//       r++

// ----------- fim array.js--------------

}).call(this);
